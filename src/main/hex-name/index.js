// # Hex-based strict Unicode names
// This module exports functions that look up characters with dynamically
// generated strict Name values that are based on their scalars’ hex codes.
//
// This source code is subject to the [Mozilla Public License v2.0][MPL].
// [MPL]: https://mozilla.org/MPL/2.0/

import fuzzilyFold from '../fuzzy-fold/';
import {
  getNumberFromHex, getPaddedHexFromCodePoint, getCodePointsFromString,
} from '../string/';

// There are twelve spans of scalars that have dynamically generated strict Name
// values based on their code points’ hex codes.
// `min` is an inclusive minimum.
//
// `inclusiveMax` is an inclusive maximum. (This name includes “inclusive”
// because most maximum variables in this project refer to exclusive maxima,
// just like the standard String.prototype.substring function, but the Unicode
// Standard defines these intervals using inclusive-maximum scalars.)
const hexNameRangeEntryArray = [
  { min: 0x3400, inclusiveMax: 0x4DBF,
    namePrefix: 'CJK UNIFIED IDEOGRAPH' },
  { min: 0x4E00, inclusiveMax: 0x9FFC,
    namePrefix: 'CJK UNIFIED IDEOGRAPH' },
  { min: 0x20000, inclusiveMax: 0x2A6DD,
    namePrefix: 'CJK UNIFIED IDEOGRAPH' },
  { min: 0x2A700, inclusiveMax: 0x2B734,
    namePrefix: 'CJK UNIFIED IDEOGRAPH' },
  { min: 0x2B740, inclusiveMax: 0x2B81D,
    namePrefix: 'CJK UNIFIED IDEOGRAPH' },
  { min: 0x2B820, inclusiveMax: 0x2CEA1,
    namePrefix: 'CJK UNIFIED IDEOGRAPH' },
  { min: 0x2CEB0, inclusiveMax: 0x2EBE0,
    namePrefix: 'CJK UNIFIED IDEOGRAPH' },
  { min: 0x30000, inclusiveMax: 0x3134A,
    namePrefix: 'CJK UNIFIED IDEOGRAPH' },
  { min: 0x17000, inclusiveMax: 0x187F7,
    namePrefix: 'TANGUT IDEOGRAPH' },
  { min: 0x18D00, inclusiveMax: 0x18D08,
    namePrefix: 'TANGUT IDEOGRAPH' },
  { min: 0x18B00, inclusiveMax: 0x18CD5,
    namePrefix: 'KHITAN SMALL SCRIPT CHARACTER' },
  { min: 0x1B170, inclusiveMax: 0x1B2FB,
    namePrefix: 'NUSHU CHARACTER' },
  { min: 0xF900, inclusiveMax: 0xFA6D,
    namePrefix: 'CJK COMPATIBILITY IDEOGRAPH' },
  { min: 0xFA70, inclusiveMax: 0xFAD9,
    namePrefix: 'CJK COMPATIBILITY IDEOGRAPH' },
  { min: 0x2F800, inclusiveMax: 0x2FA1D,
    namePrefix: 'CJK COMPATIBILITY IDEOGRAPH' },
];

// This helper metafunction takes a code-point integer and returns a helper
// function that takes a scalar range object `{ min, inclusiveMax }` and returns
// whether the given code point is within that range.
function createHexNameCodePointMatcher (codePoint) {
  return function hexNameCharacterMatcher ({ min, inclusiveMax }) {
    return min <= codePoint && codePoint <= inclusiveMax;
  }
}

// This function accepts a code-point integer and returns a boolean for whether
// it has a dynamically generated strict Name value.
export function isHexNameScalar (codePoint) {
  return hexNameRangeEntryArray.find(createHexNameCodePointMatcher(codePoint));
}

// This function accepts an `input` string argument and returns a name entry for
// the strict Name property string for that character – if that character’s
// strict Name value is one that is dynamically generated by its hex, such as
// `CJK UNIFIED IDEOGRAPH-3400` for `U+3400`. Otherwise, the function returns
// `undefined`.
export function getHexStrictNameEntry (input) {
  const inputHasSingleCodePoint = getCodePointsFromString(input).length === 1;
  if (inputHasSingleCodePoint) {
    const codePoint = input.codePointAt(0);
    const matchingHexNameRangeEntry =
      hexNameRangeEntryArray.find(createHexNameCodePointMatcher(codePoint));

    if (matchingHexNameRangeEntry) {
      const { namePrefix } = matchingHexNameRangeEntry;
      const name = `${namePrefix}-${getPaddedHexFromCodePoint(codePoint)}`;
      const nameType = null;
      return [ name, nameType ];
    }
  }
}

// This function accepts a `fuzzyName` string argument and returns the character
// string (if any) whose strict Name property string is a hex-based name (such
// as `'CJK UNIFIED IDEOGRAPH-3400'` for `U+3400`) that fuzzily matches the
// given `fuzzyName`. Otherwise, the function returns `undefined`. `fuzzyName`
// must be a fuzzily folded string (see `fuzzilyFold` from `./fuzzy-fold`).
export function getHexNameCharacter (fuzzyName) {
  for (const hexNameRangeEntry of hexNameRangeEntryArray) {
    const fuzzyNamePrefix = fuzzilyFold(hexNameRangeEntry.namePrefix);
    if (fuzzyName.startsWith(fuzzyNamePrefix)) {
      const codePointHex = fuzzyName.substring(fuzzyNamePrefix.length);
      const codePoint = getNumberFromHex(codePointHex);
      const codePointIsValid = codePoint != null
        && createHexNameCodePointMatcher(codePoint)(hexNameRangeEntry);
      if (codePointIsValid)
        return String.fromCodePoint(codePoint);
    }
  }
}
